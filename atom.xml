<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>诡隐沦</title>
  <icon>https://www.gravatar.com/avatar/01b0ad62ddaa9747b5ec0efc6199c17f</icon>
  <subtitle>我很好奇!</subtitle>
  <link href="https://guiyinlun.com/atom.xml" rel="self"/>
  
  <link href="https://guiyinlun.com/"/>
  <updated>2024-06-06T09:26:38.204Z</updated>
  <id>https://guiyinlun.com/</id>
  
  <author>
    <name>诡隐沦</name>
    <email>1178814817@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>即刻短文essay.yml配置项by安知鱼</title>
    <link href="https://guiyinlun.com/post/4f8d4e0e.html"/>
    <id>https://guiyinlun.com/post/4f8d4e0e.html</id>
    <published>2024-06-06T09:08:22.000Z</published>
    <updated>2024-06-06T09:26:38.204Z</updated>
    
    <content type="html"><![CDATA[<p>教程来自<strong>安知鱼</strong>大佬，详细看<a href="https://docs.anheyu.com/page/essay.html">官方文档</a></p><p>本文只对 <strong>essay.yml</strong> 文件做记录说明，不含搭建教程</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">title:</span> <span class="string">即刻短文</span></span><br><span class="line">  <span class="attr">subTitle:</span> <span class="string">咸鱼的日常生活。</span></span><br><span class="line">  <span class="attr">tips:</span> <span class="string">随时随地，分享生活</span></span><br><span class="line">  <span class="attr">buttonText:</span> <span class="string">关于我</span></span><br><span class="line">  <span class="attr">buttonLink:</span> <span class="string">/about/</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">home_essay:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">top_background:</span> <span class="string">https://img02.anheyu.com/adminuploads/1/2022/08/21/630249e2df20f.jpg</span></span><br><span class="line">  <span class="attr">essay_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">content:</span> <span class="string">安知鱼主题指南</span></span><br><span class="line">      <span class="attr">date:</span> <span class="number">2023</span><span class="string">/09/09</span></span><br><span class="line">      <span class="attr">video:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">https://player.bilibili.com/player.html?aid=226886152&amp;bvid=BV1Ch41137tR&amp;cid=1081639816&amp;p=1&amp;autoplay=0</span></span><br><span class="line">      <span class="attr">video:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/npm/anzhiyu-blog-static@1.0.0/video/%E9%A3%8E%E8%BD%A6%E6%A0%B7%E5%BC%8F%E6%95%88%E6%9E%9C%E9%A2%84%E8%A7%88.mp4</span></span><br><span class="line">      <span class="attr">image:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">https://img02.anheyu.com/adminuploads/1/2023/07/01/64a033cb2c21e.webp!blogimg</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">https://bu.dusays.com/2023/04/09/64329399e285d.webp</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">https://bu.dusays.com/2023/04/09/64329399aa3bc.webp</span></span><br><span class="line">      <span class="attr">address:</span> <span class="string">长沙</span></span><br><span class="line">      <span class="attr">from:</span> <span class="string">安知鱼</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">/posts/e140.html</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://blog.anheyu.com/music/?id=7269231710&amp;server=tencent</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://blog.anheyu.com/album/</span></span><br><span class="line">      <span class="attr">aplayer:</span></span><br><span class="line">        <span class="attr">server:</span> <span class="string">tencent</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">001FGQba3i10mw</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;教程来自&lt;strong&gt;安知鱼&lt;/strong&gt;大佬，详细看&lt;a href=&quot;https://docs.anheyu.com/page/essay.html&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文只对 &lt;strong&gt;essay.yml&lt;/strong&gt; 文件做记录说明，不</summary>
      
    
    
    
    <category term="hexo" scheme="https://guiyinlun.com/categories/hexo/"/>
    
    
    <category term="教程" scheme="https://guiyinlun.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="hexo" scheme="https://guiyinlun.com/tags/hexo/"/>
    
    <category term="博客搭建" scheme="https://guiyinlun.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>基金指数</title>
    <link href="https://guiyinlun.com/post/50b12041.html"/>
    <id>https://guiyinlun.com/post/50b12041.html</id>
    <published>2024-05-30T08:02:32.000Z</published>
    <updated>2024-06-06T01:52:51.744Z</updated>
    
    
    
    
    <category term="基金" scheme="https://guiyinlun.com/categories/%E5%9F%BA%E9%87%91/"/>
    
    
    <category term="基金" scheme="https://guiyinlun.com/tags/%E5%9F%BA%E9%87%91/"/>
    
    <category term="教程" scheme="https://guiyinlun.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="攻略" scheme="https://guiyinlun.com/tags/%E6%94%BB%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>造梦西游3关卡及掉落</title>
    <link href="https://guiyinlun.com/post/84f45425.html"/>
    <id>https://guiyinlun.com/post/84f45425.html</id>
    <published>2024-05-30T08:02:03.000Z</published>
    <updated>2024-06-06T01:57:59.370Z</updated>
    
    <content type="html"><![CDATA[<p>w为威威威威</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;w为威威威威&lt;/p&gt;
</summary>
      
    
    
    
    <category term="游戏" scheme="https://guiyinlun.com/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="教程" scheme="https://guiyinlun.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="攻略" scheme="https://guiyinlun.com/tags/%E6%94%BB%E7%95%A5/"/>
    
    <category term="造梦西游" scheme="https://guiyinlun.com/tags/%E9%80%A0%E6%A2%A6%E8%A5%BF%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>EasyX库使用</title>
    <link href="https://guiyinlun.com/post/13151138.html"/>
    <id>https://guiyinlun.com/post/13151138.html</id>
    <published>2024-05-30T08:00:57.000Z</published>
    <updated>2024-06-05T09:36:32.241Z</updated>
    
    <content type="html"><![CDATA[<p>创建窗口</p><p>#include <graphics.h>        // 引用图形库头文件 #include <conio.h> int main() {    initgraph(640, 480);    // 创建绘图窗口，大小为 640x480 像素    circle(200, 200, 100);    // 画圆，圆心(200, 200)，半径 100    _getch();                // 按任意键继续    closegraph();            // 关闭绘图窗口    return 0; }</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;创建窗口&lt;/p&gt;
&lt;p&gt;#include &lt;graphics.h&gt;        // 引用图形库头文件 #include &lt;conio.h&gt; int main() {    initgraph(640, 480);    // 创建绘图窗口，大小为 640x480 像素 </summary>
      
    
    
    
    <category term="EasyX" scheme="https://guiyinlun.com/categories/EasyX/"/>
    
    
    <category term="#C++" scheme="https://guiyinlun.com/tags/C/"/>
    
    <category term="#EasyX" scheme="https://guiyinlun.com/tags/EasyX/"/>
    
    <category term="#教程" scheme="https://guiyinlun.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2024五一云南</title>
    <link href="https://guiyinlun.com/post/36997b1b.html"/>
    <id>https://guiyinlun.com/post/36997b1b.html</id>
    <published>2024-05-28T06:49:28.000Z</published>
    <updated>2024-06-06T01:52:45.883Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5-1-武汉-丽江-13-45-16-30"><a href="#5-1-武汉-丽江-13-45-16-30" class="headerlink" title="5.1 武汉-丽江(13:45-16:30)"></a>5.1 武汉-丽江(13:45-16:30)</h4><ul><li><p>机场巴士 20</p><p>机场出门就有，自助机就可以买票</p></li><li><p>丽江古城</p><p>巴士下车就在丽江古城门口，里面几乎就是拍照，报团，咖啡，晚上围着篝火跳舞，酒吧很热闹</p></li><li><p>住丽江古城南门附近</p><p>附近太多小民宿了，在网上买了一个客运站附近的，一路上看到我背包客疯狂拉我住宿，到订的民俗后问了老板价格比网上便宜，果断退了，直接付钱，老板是个大爷但是我还是叫叔，总是微笑，说话态度很好，晚上正好买了明天客车最后一张车票，然后躺着真的一个人来旅游了，还是挺神奇</p></li></ul><h4 id="5-2-丽江-虎跳峡"><a href="#5-2-丽江-虎跳峡" class="headerlink" title="5.2 丽江-虎跳峡"></a>5.2 丽江-虎跳峡</h4><ul><li><p>早上丽江客运站乘坐大巴-上虎跳50-纳西雅阁<del>20</del> 30 或  <del>古城拼车80</del></p><p>昨天让大叔联系了拼车的都得120了，不划算就买了客车票，早上早早起了，在隔壁吃了碗鸡肉米线13，很多肉，只卖13，在古城里面吃的一点点肉丝的米线都15，到车站后，很多人都是背着包，包上插着登山杖，下车后买了50的门票，现在想想好亏，路上好像没有检查票的，我徒步也没在景区停留，拼车30到徒步的起点，简单收拾后就开始第一次徒步了</p></li><li><p>纳西雅阁-halfway客栈</p><p>这是第一天的路线，路上人很多，但是一点不挤，节假日的话，对比武汉重庆的人还是冰山一角，虽然是第一次来，但是路上的指路牌，景色已经看过好多次了。没多久就到了第一关28道拐，这是一段爬升的山路，刚开始就已经喘气了，平时也没锻炼，还是有点吃力的，如果坚持不下来，路上有骑马上去的，只需300大洋，印象最深的是一个背着很大包的姐姐，看到她在一旁撑着腰休息，脸已经很红很红了，我甚至觉得她会放弃，但是最后在halfway的天台看见她了，真的很厉害。28道拐的顶点的一个休息站，当然东西卖的很贵，没到饿死渴死之前我是不可能买的，找了个路人小哥和那个墙合影后就继续出发了，后面的路就很好走了，可以慢慢欣赏风景了，一路上在悬崖旁边，对面是雪山，路上有断断续续的网红打卡地，看着大家互相拍照，我也会想，有朋友一起来还是很好的。下一站是茶马客栈，到这里已经是中午了，大家在这里午餐，价格还是可以接受的，但是人太多了，买了两瓶水就接着出发了8块大洋，外面下起了小雨，路上的人渐渐少了，以至于前后可视范围内，已经没有人了。到了手摇咖啡小哥的打卡地了，花费30，让老板拍了照片，拍的还不错，不愧我消费了，哈哈哈哈，四点到达halfway，天台已经很多人，第一天的脚感觉已经废了，一直坐到冷风才走，晚上天气不是很好，没有看到日落的日照金山。大家排队和“爽死你大阳台”合照，与身后的雪山合照，我只是静静的在旁边看着，帮一对情侣拍了照，帮小姐姐一家拍了合照，大家都笑的很开心，忘记了一路的疲惫。</p></li><li><p>住halfway附近客栈</p></li></ul><p>​        后面才发现已经忘记订客栈了，几乎打遍了附近老板的电话都没有床位了，六点厚着脸皮往前面走了，地图        的显示七八公里，但是我知道天黑之前可能走不到了，天渐渐黑了，风特别大，路上一个人都没有，我感到        恐惧了，来自大自然的畏惧，巨大的峡谷和山壁，觉得自己好渺小，可能幸运女神是站在我身边的，一家客        栈的老板打电话说有客人取消了，于是花费<del>320</del>280大洋住下了，房间特别特别特别大，以至于我睡觉都还有        点怕，这家客栈应该是新修的，整个房间以及设施特别新，一个人住有点奢侈了。在附近客栈点了两个菜，        我狼吞虎咽的，第一次体验到很撑但是很饿的感觉。晚安。</p><h4 id="5-3-虎跳峡-丽江"><a href="#5-3-虎跳峡-丽江" class="headerlink" title="5.3 虎跳峡-丽江"></a>5.3 虎跳峡-丽江</h4><ul><li>halfway客栈-中虎跳</li><li>住束河古镇附近</li></ul><h4 id="5-4-丽江"><a href="#5-4-丽江" class="headerlink" title="5.4 丽江"></a>5.4 丽江</h4><ul><li>7：00束河古镇-东巴谷</li><li>耗牛坪-蓝月谷-丽江古城</li><li>住丽江古城南门附近</li></ul><h4 id="5-5-丽江-大理-7-28-9-07"><a href="#5-5-丽江-大理-7-28-9-07" class="headerlink" title="5.5 丽江-大理(7:28-9:07)"></a>5.5 丽江-大理(7:28-9:07)</h4><ul><li><p>景区直通车-大理古城5</p></li><li><p>苍山</p></li><li>住大理古城南门附近</li></ul><h4 id="5-6-大理"><a href="#5-6-大理" class="headerlink" title="5.6 大理"></a>5.6 大理</h4><ul><li>大理古城南门-才村码头-海舌公园-喜洲古镇-大理古城</li><li>住大理古城南门附近</li></ul><h4 id="5-7-大理-昆明-14-38-16-55-昆明-武汉-19-55-22-10"><a href="#5-7-大理-昆明-14-38-16-55-昆明-武汉-19-55-22-10" class="headerlink" title="5.7 大理-昆明(14:38-16:55) -昆明-武汉(19:55-22:10)"></a>5.7 大理-昆明(14:38-16:55) -昆明-武汉(19:55-22:10)</h4><ul><li>回家</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;5-1-武汉-丽江-13-45-16-30&quot;&gt;&lt;a href=&quot;#5-1-武汉-丽江-13-45-16-30&quot; class=&quot;headerlink&quot; title=&quot;5.1 武汉-丽江(13:45-16:30)&quot;&gt;&lt;/a&gt;5.1 武汉-丽江(13:45-16:30)</summary>
      
    
    
    
    <category term="旅游" scheme="https://guiyinlun.com/categories/%E6%97%85%E6%B8%B8/"/>
    
    
    <category term="五一" scheme="https://guiyinlun.com/tags/%E4%BA%94%E4%B8%80/"/>
    
    <category term="云南" scheme="https://guiyinlun.com/tags/%E4%BA%91%E5%8D%97/"/>
    
    <category term="虎跳峡" scheme="https://guiyinlun.com/tags/%E8%99%8E%E8%B7%B3%E5%B3%A1/"/>
    
  </entry>
  
  <entry>
    <title>重生的我再读小学语文，精华再赏！</title>
    <link href="https://guiyinlun.com/post/1d2ba49c.html"/>
    <id>https://guiyinlun.com/post/1d2ba49c.html</id>
    <published>2023-09-20T02:49:55.000Z</published>
    <updated>2023-09-20T09:41:51.944Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>重生的我再读语文，精华再赏！</p><p>2023年9月20启动，小时候不懂，属实是野猪品不了细糠！记录每篇写的好的文章，表达感受以及评分，满分为10分。</p><p>此篇为小学语文记录，回忆童年。</p><p>待续中~</p></blockquote><h3 id="有礼貌"><a href="#有礼貌" class="headerlink" title="有礼貌"></a>有礼貌</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大公鸡，有礼貌，见了太阳就问好。</span><br><span class="line">太阳公公眯眯笑，奖他一顶大红帽。</span><br></pre></td></tr></table></figure><ul><li>拟人修辞手法，将公鸡打鸣比作向太阳问好，“奖”：不说鸡冠是自己长出来，反倒说是太阳奖励，也表达了对太阳的尊敬，对公鸡的勤劳。</li><li>评分：8</li></ul><h3 id="月儿弯弯"><a href="#月儿弯弯" class="headerlink" title="月儿弯弯"></a>月儿弯弯</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">月儿弯弯挂蓝天,小溪弯弯出青山,</span><br><span class="line">大河弯弯流入海,街道弯弯到校园。</span><br></pre></td></tr></table></figure><ul><li>双押x4，“大河弯弯流入海”直接就是引起一波音乐回忆~</li><li>评分：6</li></ul><h3 id="彩虹"><a href="#彩虹" class="headerlink" title="彩虹"></a>彩虹</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">雨过天晴白云飘,蓝天架起彩虹桥。</span><br><span class="line">赤橙黄绿青蓝紫,数数颜色有七道。</span><br></pre></td></tr></table></figure><ul><li>家人们，这首属实是回忆杀了，朗朗上口，富含哲理，一首能记住彩虹颜色的好诗！</li><li>评分：10</li></ul><h3 id="一去二三里"><a href="#一去二三里" class="headerlink" title="一去二三里"></a>一去二三里</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一去二三里，烟村四五家。</span><br><span class="line">亭台六七座，八九十枝花。</span><br></pre></td></tr></table></figure><ul><li>将一至十写于诗中，还记得小学老师是要求背了的，哈哈哈，虽然很简单</li><li>评分：8</li></ul><h3 id="小小竹排画中游"><a href="#小小竹排画中游" class="headerlink" title="小小竹排画中游"></a>小小竹排画中游</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小竹排,顺水流，鸟儿唱，鱼儿游。</span><br><span class="line">两岸树木密，禾苗绿油油。</span><br><span class="line">江南鱼米乡,小小竹排画中游。</span><br></pre></td></tr></table></figure><ul><li>为啥读起来就自带bgm，小学的诗读起来好像在唱歌？</li><li>评分：7</li></ul><h3 id="静夜思"><a href="#静夜思" class="headerlink" title="静夜思"></a>静夜思</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静夜思</span><br><span class="line">李白</span><br><span class="line">床前明月光,疑是地上霜。</span><br><span class="line">举头望明月,低头思故乡。</span><br></pre></td></tr></table></figure><ul><li>原来第一首古诗词是静夜诗啊，经典中的经典了，奈何一年级又怎能懂得这份思乡之情</li><li>评分：10</li></ul><h3 id="影子"><a href="#影子" class="headerlink" title="影子"></a>影子</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">影子在前，影子在后，</span><br><span class="line">影子常常跟着我，就像一条小黑狗。</span><br><span class="line">影子在左，影子在右,</span><br><span class="line">影子常常陪着我，它是我的好朋友。</span><br></pre></td></tr></table></figure><ul><li>只有影子不会离开你吗？黑夜又有谁陪伴呢？</li><li>评分：7</li></ul><h3 id="东西南北"><a href="#东西南北" class="headerlink" title="东西南北"></a>东西南北</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">早晨起来,面向太阳。</span><br><span class="line">前面是东,后面是西,</span><br><span class="line">左面是北,右面是南。</span><br></pre></td></tr></table></figure><ul><li>实用性++,和彩虹异曲同工之妙</li><li>评分：8</li></ul><h3 id="日月明"><a href="#日月明" class="headerlink" title="日月明"></a>日月明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日月明，鱼羊鲜,小土尘，小大尖。</span><br><span class="line">一火灭,田力男，人木休，手目看。</span><br><span class="line">二木林，三木森,二人从，三人众。</span><br></pre></td></tr></table></figure><ul><li>这个我也会，一二三</li><li>评分：8</li></ul><h3 id="悯农"><a href="#悯农" class="headerlink" title="悯农"></a>悯农</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">李绅</span><br><span class="line">锄禾日当午，汗滴禾下土。</span><br><span class="line">谁知盘中餐，粒粒皆辛苦。</span><br></pre></td></tr></table></figure><ul><li>谁又能想到写出这样千古名诗的作者，后面是个祸害百姓的贪官</li><li>评分：9</li></ul><h3 id="雪孩子"><a href="#雪孩子" class="headerlink" title="雪孩子"></a>雪孩子</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下了一天一夜的大雪。房子上，树上，地上一片白。</span><br><span class="line">兔妈妈要出去找吃的。她堆了一个漂亮的雪孩子,让他和小白兔一起玩。</span><br><span class="line">看着可爱的雪孩子，小白兔真高兴。他和雪孩子又唱又跳,玩得很开心。</span><br><span class="line">小白兔玩累了，就回家休息。屋子里很冷，他往火里加了一些柴，就上床睡觉了。</span><br><span class="line">火把旁边的柴堆烧着了。小白兔睡得正香，一点儿也不知道。</span><br><span class="line">雪孩子看见小白兔家着火了,就飞快地跑了过去。</span><br><span class="line">雪孩子从大火中救出了小白兔，自己却化了。</span><br><span class="line">雪孩子哪里去了呢?他飞到了空中,成了一朵白云,一朵很美很美的云。</span><br></pre></td></tr></table></figure><center class="half"><img src="https://cdn.jsdelivr.net/gh/guiyinlun/myimg/mdimg/202309201504648.png" width=180/><img src="https://cdn.jsdelivr.net/gh/guiyinlun/myimg/mdimg/202309201504363.png" width=180/><img src="https://cdn.jsdelivr.net/gh/guiyinlun/myimg/mdimg/202309201504773.png" width=180/><img src="https://cdn.jsdelivr.net/gh/guiyinlun/myimg/mdimg/202309201504213.png" width=180/></center><ul><li>小雪人我哭死，小白兔下次不能这么不小心了（笑脸）</li><li>评分：9</li></ul><p>q</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;重生的我再读语文，精华再赏！&lt;/p&gt;
&lt;p&gt;2023年9月20启动，小时候不懂，属实是野猪品不了细糠！记录每篇写的好的文章，表达感受以及评分，满分为10分。&lt;/p&gt;
&lt;p&gt;此篇为小学语文记录，回忆童年。&lt;/p&gt;
&lt;p&gt;待续中~&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    <category term="语文" scheme="https://guiyinlun.com/categories/%E8%AF%AD%E6%96%87/"/>
    
    
    <category term="#小学语文" scheme="https://guiyinlun.com/tags/%E5%B0%8F%E5%AD%A6%E8%AF%AD%E6%96%87/"/>
    
    <category term="#重修" scheme="https://guiyinlun.com/tags/%E9%87%8D%E4%BF%AE/"/>
    
    <category term="#精华再赏" scheme="https://guiyinlun.com/tags/%E7%B2%BE%E5%8D%8E%E5%86%8D%E8%B5%8F/"/>
    
  </entry>
  
  <entry>
    <title>hexo个人博客搭建</title>
    <link href="https://guiyinlun.com/post/36997b1b.html"/>
    <id>https://guiyinlun.com/post/36997b1b.html</id>
    <published>2023-09-11T06:15:14.000Z</published>
    <updated>2024-06-06T09:10:34.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为第一篇文章，那么网站搭建的教程就最适合不过，记录过程，也记录自己踩的坑。</p></blockquote><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>安装<a href="https://registry.npmmirror.com/binary.html?path=node/latest-v18.x/">Node.js</a>和<a href="https://blog.csdn.net/fzx1597965407/article/details/124371720">Git</a></p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><ul><li>首先注册一个『GitHub』帐号，已有的默认默认请忽略</li><li>建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』</li><li>添加SSH公钥到『Account settings -&gt; SSH Keys -&gt; Add SSH Key』</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>建立一个空文件夹，比如D:\3-Projects\Blog</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br><span class="line">hexo init</span><br><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s -p 8888</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:8888/">本地页面</a>（<a href="http://localhost:8888/）">http://localhost:8888/）</a></p><ul><li>修改-config.yml文件</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"> <span class="attr">repository:</span> <span class="string">https://github.com/yourname/yourname.github.io.git</span></span><br><span class="line"> <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="comment">#yourname：修改为你的</span></span><br></pre></td></tr></table></figure><ul><li>安装hexo-deployer-git 自动部署发布工具</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>生成页面</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><ul><li>本地文件上传到Github上面</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="Butterfly-主题"><a href="#Butterfly-主题" class="headerlink" title="Butterfly 主题"></a>Butterfly 主题</h2><ul><li>主题安装</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git</span><br><span class="line">themes/butterfly</span><br></pre></td></tr></table></figure><ul><li>这里如果报错，执行如下命令后再安装主题</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><ul><li>应用主题</li></ul><p>在-config.yml文件中</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>安装插件</strong></p></li><li><p>pug 以及 stylus 的渲染器</p></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --sav</span><br></pre></td></tr></table></figure><ul><li>生成文章唯一链接</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><ul><li>_config.yml 找到 permalink：</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="comment">#修改为</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">post/:abbrlink.html</span> <span class="comment"># post为自定义前缀</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line"><span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">    <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br></pre></td></tr></table></figure><ul><li><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a><strong>发布博客</strong></h2></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br><span class="line">hexo new post &quot;新建博客文章名&quot;</span><br><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s -p 8888</span><br></pre></td></tr></table></figure><ul><li>博客头</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">hexo个人博客搭建</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-09-11 14:15:14</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;#hexo&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;#教程&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;#博客搭建&#x27;</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="后续美化"><a href="#后续美化" class="headerlink" title="后续美化"></a>后续美化</h2><p><a href="https://butterfly.js.org/posts/4aa8abbe/">Butterfly 安裝文檔(三) 主題配置-1 | Butterfly</a></p><p><a href="http://haiyong.site/tags/hexo/">标签: hexo | 海拥 (haiyong.site)</a></p><p><a href="https://www.fomal.cc/categories/魔改教程/">分类: 魔改教程 | Fomalhaut🥝</a></p><p><a href="https://blog.anheyu.com/posts/sdxhu.html">butterfly 重装日记 | 安知鱼 (anheyu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;作为第一篇文章，那么网站搭建的教程就最适合不过，记录过程，也记录自己踩的坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环</summary>
      
    
    
    
    <category term="hexo" scheme="https://guiyinlun.com/categories/hexo/"/>
    
    
    <category term="教程" scheme="https://guiyinlun.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="hexo" scheme="https://guiyinlun.com/tags/hexo/"/>
    
    <category term="博客搭建" scheme="https://guiyinlun.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>STL六大组件</title>
    <link href="https://guiyinlun.com/post/829e67e9.html"/>
    <id>https://guiyinlun.com/post/829e67e9.html</id>
    <published>2023-09-07T09:06:15.000Z</published>
    <updated>2024-06-06T01:52:39.007Z</updated>
    
    <content type="html"><![CDATA[<h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；</p><h3 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h3><p>提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；</p><p>迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator.</p><h3 id="算法（Algorithm）"><a href="#算法（Algorithm）" class="headerlink" title="算法（Algorithm）"></a>算法（Algorithm）</h3><p>是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；</p><p>算法部分主要由头文件，和组成。</p><p>STL中算法大致分为四类：</p><ul><li>非可变序列算法：指不直接修改其所操作的容器内容的算法。</li><li>可变序列算法：指可以修改它们所操作的容器内容的算法。</li><li>排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。</li><li>数值算法：对容器内容进行数值计算。</li></ul><p>仿函数（Functor）</p><p>我们通过在一个类中重载括号运算符的方法使用一个函数对象而不是一个普通函数。</p><p>要使用STL内建的仿函数，必须包含头文件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">display</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ia[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    for_each(ia, ia + <span class="number">5</span>, <span class="built_in">display</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器（Adaptor）"><a href="#适配器（Adaptor）" class="headerlink" title="适配器（Adaptor）"></a>适配器（Adaptor）</h3><p>什么是容器适配器</p><p>”适配器是使一种事物的行为类似于另外一种事物行为的一种机制”，适配器对容器进行包装，使其表现出另外一种行为。例 如，stack &gt;实现了栈的功能，但其内部使用顺序容器vector来存储数据。（相当于是vector表现出 了栈的行为）。</p><p>容器适配器</p><p>要使用适配器，需要加入一下头文件：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span>        <span class="comment">//stack</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span>       <span class="comment">//queue、priority_queue</span></span></span><br></pre></td></tr></table></figure><h3 id="分配器（allocator）"><a href="#分配器（allocator）" class="headerlink" title="分配器（allocator）"></a>分配器（allocator）</h3><p>其实我们可以把allocator看成一个简易的内存池，其主要适用于在使用容器时，对内存空间的动态分配，如果是我们平常要申请一块动态内存时，不推荐使用allocator，应该使用new-delete（malloc-free），主要原因是allocator不好用（使用不方便，容器例外），在内存释放的时候还需要提供对象的个数，因为我们在动态分配内存时候基本上都是对指针所指向的内存空间进行操作，而不会去记录空间中构造了多少个对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//先熟悉一下提供的allocator用法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    allocator&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="type">int</span> *ptr=a.<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line">    a.<span class="built_in">construct</span>(ptr,<span class="number">3</span>);</span><br><span class="line">    a.<span class="built_in">construct</span>(ptr+<span class="number">1</span>,<span class="number">-3</span>);</span><br><span class="line">    a.<span class="built_in">construct</span>(ptr+<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    a.<span class="built_in">construct</span>(ptr+<span class="number">3</span>,<span class="number">-3</span>);</span><br><span class="line">    a.<span class="built_in">construct</span>(ptr+<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*(ptr+i)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        a.<span class="built_in">destroy</span>(ptr+i);</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">deallocate</span>(ptr,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个分配器中一定要有allocate、deallocate、construct、destroy四个函数，分别表示内存分配，内存释放、对象构造、对象析构。在一般的allocator中allocate直接是调用::operator new()，deallocate直接调用::operator delete()，没有什么性能上的优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;容器（Container）&quot;&gt;&lt;a href=&quot;#容器（Container）&quot; class=&quot;headerlink&quot; title=&quot;容器（Container）&quot;&gt;&lt;/a&gt;容器（Container）&lt;/h3&gt;&lt;p&gt;是一种数据结构，如list，vector，和dequ</summary>
      
    
    
    
    <category term="C++" scheme="https://guiyinlun.com/categories/C/"/>
    
    
    <category term="C++" scheme="https://guiyinlun.com/tags/C/"/>
    
    <category term="STL" scheme="https://guiyinlun.com/tags/STL/"/>
    
    <category term="容器" scheme="https://guiyinlun.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="学习笔记" scheme="https://guiyinlun.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计模式23</title>
    <link href="https://guiyinlun.com/post/ac3ba24e.html"/>
    <id>https://guiyinlun.com/post/ac3ba24e.html</id>
    <published>2023-09-07T09:01:21.000Z</published>
    <updated>2024-06-06T01:53:01.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><p><strong>1、开闭原则（Open Close Principle）</strong></p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><p>开闭原则：实现热插拔，提高扩展性。</p><p>里氏代换原则：实现抽象的规范，实现子父类互相替换；</p><p>依赖倒转原则：针对接口编程，实现开闭原则的基础；</p><p>接口隔离原则：降低耦合度，接口单独设计，互相隔离；</p><p>迪米特法则，又称不知道原则：功能模块尽量独立；</p><p>合成复用原则：尽量使用聚合，组合，而不是继承；</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><strong>多态与里氏替换原则是否冲突？</strong></p><p>里氏替换原则要求特殊性不可违背普遍性，这个违背是指子类修改父类。而多态是指子类本身就父类中的普遍性进行特殊化的继承，实际上并未修改父类。所以，两者不冲突，是一种补充关系。多态使得父类的普遍性能够在子类中进行特殊化继承。里氏代换原则要求继承关系必须符合普遍性与特殊性的规律。</p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CTYPE</span> &#123;COREA, COREB&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCore</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单核A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreA</span>: <span class="keyword">public</span> SingleCore</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout\&lt;\&lt;<span class="string">&quot;SingleCore A&quot;</span>\&lt;\&lt;endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单核B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleCoreB</span>: <span class="keyword">public</span> SingleCore</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout\&lt;\&lt;<span class="string">&quot;SingleCore B&quot;</span>\&lt;\&lt;endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCore</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多核A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreA</span> : <span class="keyword">public</span> MultiCore</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout\&lt;\&lt;<span class="string">&quot;Multi Core A&quot;</span>\&lt;\&lt;endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多核B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiCoreB</span> : <span class="keyword">public</span> MultiCore</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout\&lt;\&lt;<span class="string">&quot;Multi Core B&quot;</span>\&lt;\&lt;endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.简单工厂模式</span></span><br><span class="line"></span><br><span class="line">增加新的核类型时，就需要修改工厂类</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">SingleCore\* <span class="built_in">CreateSingleCore</span>(<span class="keyword">enum</span> CTYPE ctype)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ctype == COREA) <span class="comment">//工厂内部判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreA</span>(); <span class="comment">//生产核A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ctype == COREB)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SingleCoreB</span>(); <span class="comment">//生产核B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.工厂方法模式</span></span><br><span class="line"></span><br><span class="line">每增加一种产品，就需要增加一个对象的工厂</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> SingleCore\* <span class="built_in">CreateSingleCore</span>() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产A核的工厂</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span>: <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SingleCoreA\* <span class="built_in">CreateSingleCore</span>() &#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreA; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生产B核的工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryB</span>: <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SingleCoreB\* <span class="built_in">CreateSingleCore</span>() &#123; <span class="keyword">return</span> <span class="keyword">new</span> SingleCoreB; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂模式（Abstract-Factory-Pattern）"><a href="#抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="抽象工厂模式（Abstract Factory Pattern）"></a>抽象工厂模式（Abstract Factory Pattern）</h2><p>//3.抽象工厂模式</p><p>//工厂</p><p>class CoreFactory</p><p>{</p><p>public:</p><p>virtual SingleCore* CreateSingleCore() = 0;</p><p>virtual MultiCore* CreateMultiCore() = 0;</p><p>};</p><p>//工厂A，专门用来生产A型号的处理器</p><p>class FactoryA :public CoreFactory</p><p>{</p><p>public:</p><p>SingleCore* CreateSingleCore() { return new SingleCoreA(); }</p><p>MultiCore* CreateMultiCore() { return new MultiCoreA(); }</p><p>};</p><p>//工厂B，专门用来生产B型号的处理器</p><p>class FactoryB : public CoreFactory</p><p>{</p><p>public:</p><p>SingleCore* CreateSingleCore() { return new SingleCoreB(); }</p><p>MultiCore* CreateMultiCore() { return new MultiCoreB(); }</p><p>};</p><p>区别：工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个</p><h2 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h2><p>//Singleton.h</p><p>class Singleton</p><p>{</p><p>public:</p><p>static Singleton* GetInstance();</p><p>void DeleteInstance();</p><p>private:</p><p>Singleton() {}</p><p>static Singleton *singleton;</p><p>};</p><p>//Singleton.cpp</p><p>Singleton* Singleton::singleton = NULL;</p><p>Singleton* Singleton::GetInstance()</p><p>{</p><p>if(singleton == NULL)</p><p>singleton = new Singleton();</p><p>//singleton = new(std::nothrow) Singleton();</p><p>//在内存不足时，new (std::nothrow)并不抛出异常，而是将指针置NULL</p><p>return singleton;</p><p>}</p><p>void Singleton::DeleteInstance(){</p><p>if (m_Instance!=NULL)</p><p>{</p><p>delete m_Instance;</p><p>m_Instance = NULL;</p><p>}</p><p>}</p><h2 id="建造者模式（Builder-Pattern）"><a href="#建造者模式（Builder-Pattern）" class="headerlink" title="建造者模式（Builder Pattern）"></a>建造者模式（Builder Pattern）</h2><p>class Builder</p><p>{</p><p>public:</p><p>virtual void BuildHead() {}</p><p>virtual void BuildBody() {}</p><p>virtual void BuildLeftArm(){}</p><p>virtual void BuildRightArm() {}</p><p>virtual void BuildLeftLeg() {}</p><p>virtual void BuildRightLeg() {}</p><p>};</p><p>//构造瘦人</p><p>class ThinBuilder : public Builder</p><p>{</p><p>public:</p><p>void BuildHead() { cout\&lt;\&lt;”build thin body”\&lt;\&lt;endl; }</p><p>void BuildBody() { cout\&lt;\&lt;”build thin head”\&lt;\&lt;endl; }</p><p>void BuildLeftArm() { cout\&lt;\&lt;”build thin leftarm”\&lt;\&lt;endl; }</p><p>void BuildRightArm() { cout\&lt;\&lt;”build thin rightarm”\&lt;\&lt;endl; }</p><p>void BuildLeftLeg() { cout\&lt;\&lt;”build thin leftleg”\&lt;\&lt;endl; }</p><p>void BuildRightLeg() { cout\&lt;\&lt;”build thin rightleg”\&lt;\&lt;endl; }</p><p>};</p><p>//构造胖人</p><p>class FatBuilder : public Builder</p><p>{</p><p>public:</p><p>void BuildHead() { cout\&lt;\&lt;”build fat body”\&lt;\&lt;endl; }</p><p>void BuildBody() { cout\&lt;\&lt;”build fat head”\&lt;\&lt;endl; }</p><p>void BuildLeftArm() { cout\&lt;\&lt;”build fat leftarm”\&lt;\&lt;endl; }</p><p>void BuildRightArm() { cout\&lt;\&lt;”build fat rightarm”\&lt;\&lt;endl; }</p><p>void BuildLeftLeg() { cout\&lt;\&lt;”build fat leftleg”\&lt;\&lt;endl; }</p><p>void BuildRightLeg() { cout\&lt;\&lt;”build fat rightleg”\&lt;\&lt;endl; }</p><p>};</p><p>//构造的指挥官</p><p>class Director</p><p>{</p><p>private:</p><p>Builder *m_pBuilder;</p><p>public:</p><p>Director(Builder *builder) { m_pBuilder = builder; }</p><p>void Create(){</p><p>m_pBuilder->BuildHead();</p><p>m_pBuilder->BuildBody();</p><p>m_pBuilder->BuildLeftArm();</p><p>m_pBuilder->BuildRightArm();</p><p>m_pBuilder->BuildLeftLeg();</p><p>m_pBuilder->BuildRightLeg();</p><p>}</p><p>};</p><p>int main() int main()</p><p>{</p><p>FatBuilder thin;</p><p>Director director(&amp;thin);</p><p>director.Create();</p><p>return 0;</p><p>}</p><h2 id="原型模式（Prototype-Pattern）"><a href="#原型模式（Prototype-Pattern）" class="headerlink" title="原型模式（Prototype Pattern）"></a>原型模式（Prototype Pattern）</h2><p>//实现的关键就是实现Clone函数，对于C++来说，其实就是拷贝构造函数</p><p>//父类</p><p>class Resume</p><p>{</p><p>protected:</p><p>char *name;</p><p>public:</p><p>Resume() {}</p><p>virtual ~Resume() {}</p><p>virtual Resume* Clone() { return NULL; }</p><p>virtual void Set(char *n) {}</p><p>virtual void Show() {}</p><p>};</p><p>class ResumeA : public Resume</p><p>{</p><p>public:</p><p>ResumeA(const char *str); //构造函数</p><p>ResumeA(const ResumeA \&amp;r); //拷贝构造函数</p><p>~ResumeA(); //析构函数</p><p>ResumeA* Clone(); //克隆，关键所在</p><p>void Show(); //显示内容</p><p>};</p><p>ResumeA::ResumeA(const char *str)</p><p>{</p><p>if(str == NULL) {</p><p>name = new char[1];</p><p>name[0] = ‘\0’;</p><p>}</p><p>else {</p><p>name = new char[strlen(str)+1];</p><p>strcpy(name, str);</p><p>}</p><p>}</p><p>ResumeA::~ResumeA() { delete [] name;}</p><p>ResumeA::ResumeA(const ResumeA \&amp;r) {</p><p>name = new char[strlen(r.name)+1];</p><p>strcpy(name, r.name);</p><p>}</p><p>ResumeA* ResumeA::Clone() {</p><p>return new ResumeA(*this);</p><p>}</p><p>void ResumeA::Show() {</p><p>cout\&lt;\&lt;”ResumeA name : “\&lt;\&lt;name\&lt;\&lt;endl;</p><p>}</p><p>int main()</p><p>{</p><p>Resume *r1 = new ResumeA(“A”);</p><p>Resume *r2 = new ResumeB(“B”);</p><p>Resume *r3 = r1->Clone();</p><p>Resume *r4 = r2->Clone();</p><p>r1->Show(); r2->Show();</p><p>//删除r1,r2</p><p>delete r1; delete r2;</p><p>r1 = r2 = NULL;</p><p>//深拷贝所以对r3,r4无影响</p><p>r3->Show(); r4->Show();</p><p>delete r3; delete r4;</p><p>r3 = r4 = NULL;</p><p>}</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h2><p>//兼容</p><p>//双端队列</p><p>class Deque</p><p>{</p><p>public:</p><p>void push_back(int x) { cout\&lt;\&lt;”Deque push_back”\&lt;\&lt;endl; }</p><p>void push_front(int x) { cout\&lt;\&lt;”Deque push_front”\&lt;\&lt;endl; }</p><p>void pop_back() { cout\&lt;\&lt;”Deque pop_back”\&lt;\&lt;endl; }</p><p>void pop_front() { cout\&lt;\&lt;”Deque pop_front”\&lt;\&lt;endl; }</p><p>};</p><p>//顺序容器</p><p>class Sequence</p><p>{</p><p>public:</p><p>virtual void push(int x) = 0;</p><p>virtual void pop() = 0;</p><p>};</p><p>//栈</p><p>class Stack: public Sequence</p><p>{</p><p>public:</p><p>void push(int x) { deque.push_back(x); }</p><p>void pop() { deque.pop_back(); }</p><p>private:</p><p>Deque deque; //双端队列</p><p>};</p><p>//队列</p><p>class Queue: public Sequence</p><p>{</p><p>public:</p><p>void push(int x) { deque.push_back(x); }</p><p>void pop() { deque.pop_front(); }</p><p>private:</p><p>Deque deque; //双端队列</p><p>};</p><p>int main()</p><p>{</p><p>Sequence *s1 = new Stack();</p><p>Sequence *s2 = new Queue();</p><p>s1->push(1); s1->pop();</p><p>s2->push(1); s2->pop();</p><p>delete s1; delete s2;</p><p>return 0;</p><p>}</p><h2 id="桥接模式（Bridge-Pattern）"><a href="#桥接模式（Bridge-Pattern）" class="headerlink" title="桥接模式（Bridge Pattern）"></a>桥接模式（Bridge Pattern）</h2><p>//将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><p>//操作系统</p><p>class OS</p><p>{</p><p>public:</p><p>virtual void InstallOS_Imp() {}</p><p>};</p><p>class WindowOS: public OS</p><p>{</p><p>public:</p><p>void InstallOS_Imp() { cout\&lt;\&lt;”安装Window操作系统”\&lt;\&lt;endl; }</p><p>};</p><p>class LinuxOS: public OS</p><p>{</p><p>public:</p><p>void InstallOS_Imp() { cout\&lt;\&lt;”安装Linux操作系统”\&lt;\&lt;endl; }</p><p>};</p><p>class UnixOS: public OS</p><p>{</p><p>public:</p><p>void InstallOS_Imp() { cout\&lt;\&lt;”安装Unix操作系统”\&lt;\&lt;endl; }</p><p>};</p><p>//计算机</p><p>class Computer</p><p>{</p><p>public:</p><p>virtual void InstallOS(OS *os) {}</p><p>};</p><p>class DellComputer: public Computer</p><p>{</p><p>public:</p><p>void InstallOS(OS *os) { os->InstallOS_Imp(); }</p><p>};</p><p>class AppleComputer: public Computer</p><p>{</p><p>public:</p><p>void InstallOS(OS *os) { os->InstallOS_Imp(); }</p><p>};</p><p>class HPComputer: public Computer</p><p>{</p><p>public:</p><p>void InstallOS(OS *os) { os->InstallOS_Imp(); }</p><p>};</p><p>int main()</p><p>{</p><p>OS *os1 = new WindowOS();</p><p>OS *os2 = new LinuxOS();</p><p>Computer *computer1 = new AppleComputer();</p><p>computer1->InstallOS(os1);</p><p>computer1->InstallOS(os2);</p><p>}</p><h2 id="过滤器模式（Filter、Criteria-Pattern）"><a href="#过滤器模式（Filter、Criteria-Pattern）" class="headerlink" title="过滤器模式（Filter、Criteria Pattern）"></a>过滤器模式（Filter、Criteria Pattern）</h2><h2 id="组合模式（Composite-Pattern）"><a href="#组合模式（Composite-Pattern）" class="headerlink" title="组合模式（Composite Pattern）"></a>组合模式（Composite Pattern）</h2><p>将对象组合成树形结构以表示“部分-整体”的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性。注意两个字“树形”。这种树形结构在现实生活中随处可见，比如一个集团公司，它有一个母公司，下设很多家子公司。不管是母公司还是子公司，都有各自直属的财务部、人力资源部、销售部等。对于母公司来说，不论是子公司，还是直属的财务部、人力资源部，都是它的部门。整个公司的部门拓扑图就是一个树形结构。</p><h2 id="装饰器模式（Decorator-Pattern）"><a href="#装饰器模式（Decorator-Pattern）" class="headerlink" title="装饰器模式（Decorator Pattern）"></a>装饰器模式（Decorator Pattern）</h2><p>装饰模式提供了一种“即用即付”的方法来添加职责。它并不试图在一个复杂的可定制的类中支持所有可预见的特征，相反，你可以定义一个简单的类，并且用装饰类给它逐渐地添加功能。可以从简单的部件组合出复杂的功能</p><h2 id="外观模式（Facade-Pattern）"><a href="#外观模式（Facade-Pattern）" class="headerlink" title="外观模式（Facade Pattern）"></a>外观模式（Facade Pattern）</h2><p>class Scanner</p><p>{</p><p>public:</p><p>void Scan() { cout\&lt;\&lt;”词法分析”\&lt;\&lt;endl; }</p><p>};</p><p>class Parser</p><p>{</p><p>public:</p><p>void Parse() { cout\&lt;\&lt;”语法分析”\&lt;\&lt;endl; }</p><p>};</p><p>class GenMidCode</p><p>{</p><p>public:</p><p>void GenCode() { cout\&lt;\&lt;”产生中间代码”\&lt;\&lt;endl; }</p><p>};</p><p>class GenMachineCode</p><p>{</p><p>public:</p><p>void GenCode() { cout\&lt;\&lt;”产生机器码”\&lt;\&lt;endl;}</p><p>};</p><p>//高层接口</p><p>class Compiler</p><p>{</p><p>public:</p><p>void Run()</p><p>{</p><p>Scanner scanner;</p><p>Parser parser;</p><p>GenMidCode genMidCode;</p><p>GenMachineCode genMacCode;</p><p>scanner.Scan();</p><p>parser.Parse();</p><p>genMidCode.GenCode();</p><p>genMacCode.GenCode();</p><p>}</p><p>};</p><p>int main()</p><p>{</p><p>Compiler compiler;</p><p>compiler.Run();</p><p>return 0;</p><p>}</p><h2 id="享元模式（Flyweight-Pattern）"><a href="#享元模式（Flyweight-Pattern）" class="headerlink" title="享元模式（Flyweight Pattern）"></a>享元模式（Flyweight Pattern）</h2><p>以围棋为例。棋盘中含两个共享的对象，黑棋子和白棋子，所有棋子的外在属性都存放在单独的容器中。</p><h2 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h2><p>为其他对象提供一种代理以控制对这个对象的访问。有四种常用的情况：（1）远程代理，（2）虚代理，（3）保护代理，（4）智能引用。</p><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><h2 id="责任链模式（Chain-of-Responsibility-Pattern）"><a href="#责任链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="责任链模式（Chain of Responsibility Pattern）"></a>责任链模式（Chain of Responsibility Pattern）</h2><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止，类中包含一个上级对象。</p><h2 id="命令模式（Command-Pattern）"><a href="#命令模式（Command-Pattern）" class="headerlink" title="命令模式（Command Pattern）"></a>命令模式（Command Pattern）</h2><h2 id="解释器模式（Interpreter-Pattern）"><a href="#解释器模式（Interpreter-Pattern）" class="headerlink" title="解释器模式（Interpreter Pattern）"></a>解释器模式（Interpreter Pattern）</h2><h2 id="迭代器模式（Iterator-Pattern）"><a href="#迭代器模式（Iterator-Pattern）" class="headerlink" title="迭代器模式（Iterator Pattern）"></a>迭代器模式（Iterator Pattern）</h2><h2 id="中介者模式（Mediator-Pattern）"><a href="#中介者模式（Mediator-Pattern）" class="headerlink" title="中介者模式（Mediator Pattern）"></a>中介者模式（Mediator Pattern）</h2><p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</p><h2 id="备忘录模式（Memento-Pattern）"><a href="#备忘录模式（Memento-Pattern）" class="headerlink" title="备忘录模式（Memento Pattern）"></a>备忘录模式（Memento Pattern）</h2><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态</p><h2 id="观察者模式（Observer-Pattern）"><a href="#观察者模式（Observer-Pattern）" class="headerlink" title="观察者模式（Observer Pattern）"></a>观察者模式（Observer Pattern）</h2><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</p><h2 id="状态模式（State-Pattern）"><a href="#状态模式（State-Pattern）" class="headerlink" title="状态模式（State Pattern）"></a>状态模式（State Pattern）</h2><p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。它有两种使用情况：（1）一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。（2）一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。</p><h2 id="空对象模式（Null-Object-Pattern）"><a href="#空对象模式（Null-Object-Pattern）" class="headerlink" title="空对象模式（Null Object Pattern）"></a>空对象模式（Null Object Pattern）</h2><h2 id="策略模式（Strategy-Pattern）"><a href="#策略模式（Strategy-Pattern）" class="headerlink" title="策略模式（Strategy Pattern）"></a>策略模式（Strategy Pattern）</h2><p>class A{</p><p>public:</p><p>virtual void print()=0;</p><p>}</p><p>class A1{</p><p>public:</p><p>void print(){cout>>“A1”;}</p><p>}</p><p>class A2{</p><p>public:</p><p>void print(){cout>>“A2”;}</p><p>}</p><p>class Cache{</p><p>private:</p><p>A *m_a;</p><p>public:</p><p>//方法一</p><p>Cache(A *a){m_a=a;}</p><p>//方法二</p><p>Cache(enum RA ra)</p><p>{</p><p>if(ra == LRU)</p><p>m_ra = new LRU_ReplaceAlgorithm();</p><p>else if(ra == FIFO)</p><p>m_ra = new FIFO_ReplaceAlgorithm();</p><p>else if(ra == RANDOM)</p><p>m_ra = new Random_ReplaceAlgorithm();</p><p>else</p><p>m_ra = NULL;</p><p>}</p><p>~Cache(){delete m_a;}</p><p>void print({m_a->print()})</p><p>}</p><p>int main()</p><p>{</p><p>Cache cache(new LRU_ReplaceAlgorithm()); //1.暴露了算法的定义</p><p>Cache cache(LRU); //2.指定标签即可</p><p>cache.print();</p><p>return 0;</p><p>}</p><h2 id="模板模式（Template-Pattern）"><a href="#模板模式（Template-Pattern）" class="headerlink" title="模板模式（Template Pattern）"></a>模板模式（Template Pattern）</h2><p>//模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p><p>//简历</p><p>class Resume</p><p>{</p><p>protected: //保护成员</p><p>virtual void SetPersonalInfo() {}</p><p>virtual void SetEducation() {}</p><p>virtual void SetWorkExp() {}</p><p>public:</p><p>void FillResume()</p><p>{</p><p>SetPersonalInfo();</p><p>SetEducation();</p><p>SetWorkExp();</p><p>}</p><p>};</p><p>class ResumeA: public Resume</p><p>{</p><p>protected:</p><p>void SetPersonalInfo() { cout\&lt;\&lt;”A’s PersonalInfo”\&lt;\&lt;endl; }</p><p>void SetEducation() { cout\&lt;\&lt;”A’s Education”\&lt;\&lt;endl; }</p><p>void SetWorkExp() { cout\&lt;\&lt;”A’s Work Experience”\&lt;\&lt;endl; }</p><p>};</p><p>class ResumeB: public Resume</p><p>{</p><p>protected:</p><p>void SetPersonalInfo() { cout\&lt;\&lt;”B’s PersonalInfo”\&lt;\&lt;endl; }</p><p>void SetEducation() { cout\&lt;\&lt;”B’s Education”\&lt;\&lt;endl; }</p><p>void SetWorkExp() { cout\&lt;\&lt;”B’s Work Experience”\&lt;\&lt;endl; }</p><p>};</p><p>int main()</p><p>{</p><p>Resume *r1;</p><p>r1 = new ResumeA();</p><p>r1->FillResume();</p><p>delete r1;</p><p>r1 = new ResumeB();</p><p>r1->FillResume();</p><p>delete r1;</p><p>r1 = NULL;</p><p>return 0;</p><p>}</p><h2 id="访问者模式（Visitor-Pattern）"><a href="#访问者模式（Visitor-Pattern）" class="headerlink" title="访问者模式（Visitor Pattern）"></a>访问者模式（Visitor Pattern）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式六大原则&quot;&gt;&lt;a href=&quot;#设计模式六大原则&quot; class=&quot;headerlink&quot; title=&quot;设计模式六大原则&quot;&gt;&lt;/a&gt;设计模式六大原则&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、开闭原则（Open Close Principle）&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://guiyinlun.com/categories/C/"/>
    
    
    <category term="C++" scheme="https://guiyinlun.com/tags/C/"/>
    
    <category term="教程" scheme="https://guiyinlun.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="设计模式" scheme="https://guiyinlun.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://guiyinlun.com/post/4a17b156.html"/>
    <id>https://guiyinlun.com/post/4a17b156.html</id>
    <published>2023-06-07T06:38:43.000Z</published>
    <updated>2024-06-06T01:52:24.125Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="hexo" scheme="https://guiyinlun.com/categories/hexo/"/>
    
    
    <category term="#hello world" scheme="https://guiyinlun.com/tags/hello-world/"/>
    
    <category term="#hexo" scheme="https://guiyinlun.com/tags/hexo/"/>
    
    <category term="#测试" scheme="https://guiyinlun.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++学习笔记</title>
    <link href="https://guiyinlun.com/post/8675909c.html"/>
    <id>https://guiyinlun.com/post/8675909c.html</id>
    <published>2023-06-05T09:04:29.000Z</published>
    <updated>2023-09-20T03:07:08.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-视c-为一个语言联邦"><a href="#1-视c-为一个语言联邦" class="headerlink" title="1.视c++为一个语言联邦"></a><strong>1.视c++为一个语言联邦</strong></h3><ol><li><p>C</p></li><li><p>面向对象的C++</p></li><li><p>Template C++ 泛型编程</p></li><li><p>STL</p></li></ol><h3 id="2-尽量以const-enum-inline替换-define"><a href="#2-尽量以const-enum-inline替换-define" class="headerlink" title="2.尽量以const,enum,inline替换 #define"></a><strong>2.尽量以const,enum,inline替换 #define</strong></h3><p>宁可以编译器换预处理器</p><h4 id="1-define错误"><a href="#1-define错误" class="headerlink" title="1.#define错误"></a><strong>1.#define错误</strong></h4><p>#define ASPECT_RATIO 1.111</p><p>错误：你所使用的名称可能并未进入记号表</p><p>解决：const double AspectRatio = 1.111//大写通常用于宏</p><h4 id="2-特殊情况"><a href="#2-特殊情况" class="headerlink" title="2.特殊情况"></a><strong>2.特殊情况</strong></h4><h5 id="1-定义常量指针-constant-pointers-。"><a href="#1-定义常量指针-constant-pointers-。" class="headerlink" title="1.定义常量指针( constant pointers)。"></a><strong>1.定义常量指针( constant pointers)。</strong></h5><p>由于常量定义式通常被放在头文件内（以便被不同的源码含入)，因此有必要将指针（而不只是指针所指之物）声明为const。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> authorName = <span class="string">&quot;scott Meyers&quot;</span>; </span><br><span class="line"><span class="type">const</span> std:: <span class="function">string <span class="title">authorName</span> <span class="params">( <span class="string">&quot;scott Meyers&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="2-class专属常量"><a href="#2-class专属常量" class="headerlink" title="2.class专属常量"></a><strong>2.class专属常量</strong></h5><p>将常量的作用域限制于class内</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NumTurns=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">enum</span>&#123; NumTurns=<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> scores[NumTurns];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现宏错误"><a href="#2-实现宏错误" class="headerlink" title="2.实现宏错误"></a><strong>2.实现宏错误</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_ MAX(a,b) f((a) &gt; (b)? (a) : (b))</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span> (++a,b);</span><br><span class="line"><span class="comment">//a被累加二次</span></span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span> (++a,b+<span class="number">10</span>);</span><br><span class="line"><span class="comment">//a被累加一次</span></span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">//由于我们不知道</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">callwithMax</span> <span class="params">(<span class="type">const</span> T&amp; a,<span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"><span class="comment">//T是什么，所以采用</span></span></span><br><span class="line"><span class="function"><span class="comment">//pass by reference-to-const.</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(a &gt; b ? a : b)</span></span>;</span><br><span class="line"><span class="comment">//见条款20</span></span><br></pre></td></tr></table></figure><h4 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a><strong>3.小结</strong></h4><p>有了consts、enums和 inlines，我们对预处理器（特别是#define)的需求降低了，但并非完全消除。#include仍然是必需品，而#ifdef/#ifndef也继续扮演控制编译的重要角色。目前还不到预处理器全面引退的时候，但你应该明确地给予它更长更频繁的假期。</p><p>请记住：</p><ol><li><p>对于单纯常量，最好以const对象或enums替换#defines。</p></li><li><p>对于形似函数的宏（macros），最好改用inline函数替换#defines。</p></li></ol><h3 id="3-尽可能使用const"><a href="#3-尽可能使用const" class="headerlink" title="3.尽可能使用const"></a><strong>3.尽可能使用const</strong></h3><h4 id="1-const规则"><a href="#1-const规则" class="headerlink" title="1.const规则"></a><strong>1.const规则</strong></h4><h6 id="1-指针"><a href="#1-指针" class="headerlink" title="1.指针"></a>1.指针</h6><p>const语法虽然变化多端，但并不莫测高深。如果关键字const出现在星号左边，表示被指物是常量;如果出现在星号右边，表示指针自身是常量;如果出现在星号两边，表示被指物和指针两者都是常量。</p><h6 id="2-const修饰函数参数"><a href="#2-const修饰函数参数" class="headerlink" title="2.const修饰函数参数"></a>2.const修饰函数参数</h6><p>表示参数不可变，若参数为引用，可以增加效率(引用传递而不用值拷贝)</p><h6 id="3-const-修饰函数返回值"><a href="#3-const-修饰函数返回值" class="headerlink" title="3.const 修饰函数返回值"></a>3.const 修饰函数返回值</h6><p>避免返回值被修改</p><p>如果给以“指针传递”方式的函数返回值加 const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。</p><p>例如函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">GetString</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//如下语句将出现编译错误：</span></span><br><span class="line"><span class="type">char</span> *str = <span class="built_in">GetString</span>();</span><br><span class="line"><span class="comment">//正确的用法是</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = <span class="built_in">GetString</span>();</span><br></pre></td></tr></table></figure><h6 id="4-const修饰类的成员变量（class）"><a href="#4-const修饰类的成员变量（class）" class="headerlink" title="4.const修饰类的成员变量（class）"></a>4.const修饰类的成员变量（class）</h6><p>表示成员变量不能被修改，同时只能在初始化列表中赋值</p><h6 id="5-const修饰类的成员函数（class）"><a href="#5-const修饰类的成员函数（class）" class="headerlink" title="5.const修饰类的成员函数（class）"></a>5.const修饰类的成员函数（class）</h6><ol><li><p>不能修饰全局函数，因为全局函数没有this指针</p></li><li><p>该函数不能修改成员变量，方法：在变量前加 mutable ，可以更改</p></li><li><p>不能调用非const成员函数，因为任何非const成员函数会有修改成员变量的企图</p></li></ol><h6 id="6-const修饰类对象（class）"><a href="#6-const修饰类对象（class）" class="headerlink" title="6.const修饰类对象（class）"></a>6.const修饰类对象（class）</h6><ol><li><p>对象的任何成员都不能被修改</p></li><li><p>const类对象只能调用const成员函数</p></li></ol><h6 id="7-类中的所有函数都可以声明为const函数吗。哪些函数不能？（class）"><a href="#7-类中的所有函数都可以声明为const函数吗。哪些函数不能？（class）" class="headerlink" title="7.类中的所有函数都可以声明为const函数吗。哪些函数不能？（class）"></a>7.类中的所有函数都可以声明为const函数吗。哪些函数不能？（class）</h6><ol><li><p>构造函数不能</p></li><li><p>因为const修饰的成员函数不能修改成员变量。但是构造函数恰恰需要修改类的成员变量</p></li><li><p>static静态成员函数不能</p></li><li><p>static静态成员是属于类的，而不属于某个具体的对象，所有的对象共用static成员。this指针是某个具体对象的地址，因此static成员函数没有this指针。而函数中的const其实就是用来修饰this指针的，表示this指向的内容不可变，static静态成员却没有this指针，所以const不能用来修饰static成员函数</p></li></ol><h4 id="2-STL迭代器"><a href="#2-STL迭代器" class="headerlink" title="2.STL迭代器"></a><strong>2.STL迭代器</strong></h4><p>iterator和const_iterator</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std: : vector&lt;<span class="type">int</span>&gt; vec;...</span><br><span class="line"><span class="type">const</span> std: :vector&lt;<span class="type">int</span>&gt;::iterator iter =vec.<span class="built_in">begin</span> ( );<span class="comment">//iter的作用像个T*const </span></span><br><span class="line">*iter = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//没问题，改变iter所指物</span></span><br><span class="line">++iter;</span><br><span class="line"><span class="comment">//错误! iter是const</span></span><br><span class="line">std: :vector&lt;<span class="type">int</span>&gt; :: const_iterator citer =vec.<span class="built_in">begin</span> ( );<span class="comment">//cIter的作用像个const T*</span></span><br><span class="line">*cIter = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//错误!*cIter是const</span></span><br><span class="line">++cIter;</span><br><span class="line"><span class="comment">//没问题，改变cIter.</span></span><br></pre></td></tr></table></figure><h4 id="3-const成员函数"><a href="#3-const成员函数" class="headerlink" title="3.const成员函数"></a><strong>3.const成员函数</strong></h4><p>1.它们使 class接口比较容易被理解。这是因为，得知哪个函数可以改动对象内容而哪个函数不行，很是重要。</p><p>2.它们使“操作const对象”成为可能。这对编写高效代码是个关键，因为如条款20所言，改善C+程序效率的一个根本办法是以pass byreference-to-const方式传递对象，而此技术可行的前提是，我们有const成员函数可用来处理取得（并经修饰而成）的const对象。</p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a><strong>4.小结</strong></h4><ol><li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li><li>编译器强制实施bitwise constness,但你编写程序时应该使用“概念上的常量性”( conceptual constness）。</li><li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。（P55）</li></ol><h3 id="4-确定对象被使用前已确定先被初始化"><a href="#4-确定对象被使用前已确定先被初始化" class="headerlink" title="4.确定对象被使用前已确定先被初始化"></a><strong>4.确定对象被使用前已确定先被初始化</strong></h3><h4 id="1，构造函数初始化"><a href="#1，构造函数初始化" class="headerlink" title="1，构造函数初始化"></a><strong>1，构造函数初始化</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ABEntry: :<span class="built_in">ABEntry</span> (<span class="type">const</span> std::string&amp; name,<span class="type">const</span> std::string&amp; address,</span><br><span class="line"><span class="type">const</span> std: : list&lt;PhoneNumber&gt;&amp; phones)&#123;</span><br><span class="line"></span><br><span class="line">theName = name;</span><br><span class="line"></span><br><span class="line">theAddress = address;</span><br><span class="line"></span><br><span class="line">thePhones = phones;</span><br><span class="line"><span class="comment">//这些都是赋值（assignments) 而非初始化（initializations)</span></span><br><span class="line">numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。</p></li><li><p>在 ABEntry构造函数内，theName，theAddress和 thePhones 都不是被初始化，而是被赋值。</p></li><li><p>初始化的发生时间更早，发生于这些成员的default 构造函数被自动调用之时（比进入ABEntry构造函数本体的时间更早）。</p></li><li><p>但这对numTimesConsulted不为真，因为它属于内置类型，不保证一定在你所看到的那个赋值动作的时间点之前获得初值。</p></li></ol><p>ABEntry构造函数的一个较佳写法是，使用所谓的member initialization list（成员初值列）替换赋值动作:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ABEntry : :<span class="built_in">ABEntry</span>(<span class="type">const</span> std::string&amp; name,<span class="type">const</span> std::string&amp; address,</span><br><span class="line"><span class="type">const</span> std: : list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">:<span class="built_in">theName</span> (name) ,</span><br><span class="line"> <span class="built_in">theAddress</span> (address) ,</span><br><span class="line"> <span class="built_in">thePhones</span> (phones) ,</span><br><span class="line"> <span class="comment">//现在，这些都是初始化(initializations)</span></span><br><span class="line"> <span class="built_in">nunTimesConsulted</span> (o)&#123; &#125;</span><br><span class="line"> <span class="comment">//现在，构造函数本体不必有任何动作</span></span><br><span class="line"> &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数和上一个的最终结果相同，但通常效率较高。基于赋值的那个版本(本例第一版本)首先调用default构造函数为theName, theAddress和thePhones设初值，然后立刻再对它们赋予新值。default构造函数的一切作为因此浪费了。成员初值列( member initialization list）的做法避免了这一问题，因为初值列中针对各个成员变量而设的实参，被拿去作为各成员变量之构造函数的实参。本例中的theName以nane为初值进行copy构造，theAddress 以 address为初值进行copy构造，thePhones 以 phones为初值进行copy构造。</p><h4 id="2-小结"><a href="#2-小结" class="headerlink" title="2.小结"></a><strong>2.小结</strong></h4><ol><li>为内置型对象进行手工初始化，因为C+t不保证初始化它们。</li><li>构造函数最好使用成员初值列( member initialization list），而不要在构造函数本体内使用赋值操作( assignment）。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。</li><li>为免除“跨编译单元之初始化次序”问题，请以local static对象替换non-localstatic对象。</li></ol><h3 id="5-了解C-默默编写并调用了哪些函数"><a href="#5-了解C-默默编写并调用了哪些函数" class="headerlink" title="5.了解C++默默编写并调用了哪些函数"></a><strong>5.了解C++默默编写并调用了哪些函数</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123; &#125;;</span><br><span class="line"><span class="comment">//这就好像你写下这样的代码:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Empty</span>() &#123; ... &#125;</span><br><span class="line"><span class="comment">//default构造函数</span></span><br><span class="line"><span class="built_in">Ermpty</span>(<span class="type">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line"><span class="comment">//copy构造函数</span></span><br><span class="line">~<span class="built_in">Empty</span>( ) &#123; ... &#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Emptys rhs)&#123; ... &#125; </span><br><span class="line"><span class="comment">//copy assignment操作符.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-若不想使用编译器自动生成的函数，就应该明确拒绝"><a href="#6-若不想使用编译器自动生成的函数，就应该明确拒绝" class="headerlink" title="6.若不想使用编译器自动生成的函数，就应该明确拒绝"></a><strong>6.若不想使用编译器自动生成的函数，就应该明确拒绝</strong></h3><p>为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为private并且不予实现。</p><p>private: Uncopyable (const Uncopyable&amp;) ; //但阻止 copying Uncopyable&amp; operator=(const Uncopyable&amp;) ;</p><h3 id="7-为多态基类声明virtual析构函数"><a href="#7-为多态基类声明virtual析构函数" class="headerlink" title="7.为多态基类声明virtual析构函数"></a><strong>7.为多态基类声明virtual析构函数</strong></h3><h4 id="1-情况"><a href="#1-情况" class="headerlink" title="1.情况"></a>1.情况</h4><p>这是一个引来灾难的秘诀，因为CH+明白指出，当derived class对象经由一个baseclass指针被删除,而该base class带着一个non-virtual析构函数,其结果未有定义——实际执行时通常发生的是对象的derived 成分没被销毁。如果getTimeKeeper返回指针指向一个AtomicClock 对象，其内的 AtomicClock 成分（也就是声明于Atomicclock class内的成员变量〉很可能没被销毁，而atomicClock的析构函数也未能执行起来。然而其 base class成分（也就是TimeKeeper这一部分）通常会被销毁，于是造成一个诡异的“局部销毁”对象。这可是形成资源泄漏、败坏之数据结构、在调试器上浪费许多时间的绝佳途径喔。</p><h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h4><p>消除这个问题的做法很简单:给base class一个virtual析构函数.此后删除derivedclass对象就会如你想要的那般。是的，它会销毁整个对象，包括所有derived class成分</p><h4 id="3-建议"><a href="#3-建议" class="headerlink" title="3.建议"></a>3.建议</h4><ol><li><p>有不同的实现码。任何 class只要带有 virtual函数都几乎确定应该也有一个virtual析构函数。</p></li><li><p>如果class不含virtual函数，通常表示它并不意图被用做一个base class。</p></li><li><p>当class不企图被当作base class，令其析构函数为virtual往往是个馒主意。</p></li></ol><h4 id="4-抽象类"><a href="#4-抽象类" class="headerlink" title="4.抽象类"></a>4.抽象类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AwOV</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~AWOV &#123; ) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个class有一个pure virtual函数，所以它是个抽象class，又由于它有个virtual析构函数，所以你不需要担心析构函数的问题。</p><p>然而这里有个窍门:你必须为这个pure virtual析构函数提供一份定义:   AwOV : : ~AWOV() { }</p><h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><ol><li><p>polymorphic（带多态性质的）base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。</p></li><li><p>Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性( polymorphically)，就不该声明virtual析构函数。</p></li></ol><h3 id="8-别让异常逃离析构函数"><a href="#8-别让异常逃离析构函数" class="headerlink" title="8.别让异常逃离析构函数"></a><strong>8.别让异常逃离析构函数</strong></h3><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li><p>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</p></li><li><p>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</p></li></ol><h3 id="9-绝不在构造和析构过程中调用virtial函数"><a href="#9-绝不在构造和析构过程中调用virtial函数" class="headerlink" title="9.绝不在构造和析构过程中调用virtial函数"></a><strong>9.绝不在构造和析构过程中调用virtial函数</strong></h3><p>在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class(比起当前执行构造函数和析构函数的那层)）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Base::<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base is Constructed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line">Base::~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base is Destroyed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Base::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;print Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>();</span><br><span class="line">    ~<span class="built_in">Derived</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Derived::<span class="built_in">Derived</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Derived is Constructed&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Derived::~<span class="built_in">Derived</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Derived is Destroyed&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;print Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived der;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/guiyinlun/myimg/mdimg/202309111045244.png" alt=""></p><h3 id="10-令operator-返回一个reference-to-this"><a href="#10-令operator-返回一个reference-to-this" class="headerlink" title="10.令operator = 返回一个reference to *this"></a><strong>10.令operator = 返回一个reference to *this</strong></h3><p>int x, y, z; x = y = z = 3; class widget { public: widget&amp; operator+= (const widget&amp; rhs) {    …    return *this; }</p><h3 id="11-在-operator-中处理“自我赋值”"><a href="#11-在-operator-中处理“自我赋值”" class="headerlink" title="11.在**operator = 中处理“自我赋值”**"></a><strong>11.在**</strong>operator = 中处理“自我赋值”**</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">widget&amp; widget : :<span class="keyword">operator</span>= (<span class="type">const</span> widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>);<span class="comment">//证同测试（identity test)</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span> (*rhs.pb);<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ol><li><p>确保当对象自我赋值时operator=有良好行为。</p></li><li><p>其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。</p></li><li><p>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</p></li></ol><h3 id="12-复制对象时勿忘其每一个成分"><a href="#12-复制对象时勿忘其每一个成分" class="headerlink" title="12.复制对象时勿忘其每一个成分"></a><strong>12.复制对象时勿忘其每一个成分</strong></h3><p>任何时候只要你承担起“为derived class撰写copying函数”的重责大任，必须很小心地也复制其base class成分。那些成分往往是 private(见条款22），所以你无法直接访问它们，你应该让 derived class 的 copying函数调用相应的base class函数:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs): <span class="built_in">Customer</span> (rhs) ,</span><br><span class="line"><span class="comment">//调用base class的copy构造函数</span></span><br><span class="line"><span class="built_in">priority</span> (rhs.priority)</span><br><span class="line">&#123;&#125;</span><br><span class="line">PriorityCustomer&amp;</span><br><span class="line">PriorityCustomer: :<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)&#123;</span><br><span class="line">    customer : :<span class="keyword">operator</span>=(rhs) ;</span><br><span class="line"><span class="comment">//对base class 成分进行赋值动作</span></span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>复制所有local 成员变量</li><li>调用所有base classes 内的适当的copying函数。</li></ol><h3 id="13-以对象管理资源"><a href="#13-以对象管理资源" class="headerlink" title="13.以对象管理资源"></a><strong>13.以对象管理资源</strong></h3><h4 id="1-情况-1"><a href="#1-情况-1" class="headerlink" title="1.情况"></a>1.情况</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Investment* pInv = <span class="built_in">createInvestment</span> ( ) ;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…中可能return，continue，抛出异常，使得delete语句不执行</p><h4 id="2-解决"><a href="#2-解决" class="headerlink" title="2.解决"></a>2.解决</h4><p>标准程序库提供的auto_ptr 正是针对这种形势而设计的特制产品。</p><p>auto_ptr是个“类指针(pointer-like）对象”，也就是所谓“智能指针”，其析构函数自动对其所指对象调用delete。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( )</span></span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pInv</span> <span class="params">(createInvestment ( ))</span></span>;</span><br><span class="line">    std::<span class="function">trl::shared_ptr&lt;Investment&gt; <span class="title">pInv</span> <span class="params">(createInvestment ( ))</span></span>;<span class="comment">//可以复制 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>由于auto_ptr被销毁时会自动删除它所指之物，所以一定要注意别让多个auto_ptr同时指向同一对象。</p></li><li><p>如果真是那样，对象会被删除一次以上，而那会使你的程序搭上驶向“未定义行为”的快速列车上。</p></li><li><p>为了预防这个问题，auto_ptrs有个不寻常的性质:若通过copy构造函数或copy assignment操作符复制它们，它们会变成null，而复制所得的指针将取得资源的唯一拥有权!</p></li><li><p>trl: :shared ptr和 auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它(被复制物）指向null。</p></li></ol><h3 id="14-在资源管理类中小心coping行为"><a href="#14-在资源管理类中小心coping行为" class="headerlink" title="14.在资源管理类中小心coping行为"></a><strong>14.在资源管理类中小心coping行为</strong></h3><p>Coping函数（包括copy构造函数和 copy assignmen 操作符）有可能被编译器自动创建出来，因此除非编译器所生版本做了你想要做的事（条款5提过其缺省行为），否则你得自己编写它们。</p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ol><li><p>复制RAII 对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</p></li><li><p>普遍而常见的RAI class copying 行为是:抑制copying、施行引用计数法(reference counting）。不过其他行为也都可能被实现。</p></li></ol><h3 id="15-在资源管理类中提供对原始资源的访问"><a href="#15-在资源管理类中提供对原始资源的访问" class="headerlink" title="15.在资源管理类中提供对原始资源的访问"></a><strong>15.在资源管理类中提供对原始资源的访问</strong></h3><ol><li><p>资源管理类(resource-managing classes）很棒。它们是你对抗资源泄漏的堡垒。排除此等泄漏是良好设计系统的根本性质。在一个完美世界中你将倚赖这样的classes来处理和资源之间的所有互动，而不是玷污双手直接处理原始资源（ rawresources）。但这个世界并不完美。许多APIs直接指涉资源，所以除非你发誓（这其实是一种少有实际价值的举动)永不录用这样的APIs，否则只得绕过资源管理对象(resource-managing objects）直接访问原始资源( raw resources）。</p></li><li><p>APIs往往要求访问原始资源（raw resources），所以每一个RAII class应该提供-个“取得其所管理之资源”的办法。</p></li><li><p>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。</p></li></ol><h3 id="16-成对使用new和delete时要采取相同形式"><a href="#16-成对使用new和delete时要采取相同形式" class="headerlink" title="16.成对使用new和delete时要采取相同形式"></a><strong>16.成对使用new和delete时要采取相同形式</strong></h3><p>规则：如果你调用new时使用[ ]，你必须在对应调用delete时也使用[ ]。如果你调用new时没有使用[ ]，那么也不该在对应调用delete时使用[ ]。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string*stringPtr1 = <span class="keyword">new</span> std::string;</span><br><span class="line">std::string*stringPtr2 = <span class="keyword">new</span> std::string [ <span class="number">100</span>];</span><br><span class="line"><span class="keyword">delete</span> stringPtr1;</span><br><span class="line"><span class="comment">//删除一个对象</span></span><br><span class="line"><span class="keyword">delete</span> [ ] stringPtr2;</span><br><span class="line"><span class="comment">//删除一个由对象组成的数组</span></span><br></pre></td></tr></table></figure><h3 id="17-以独立语句将newed对象置入智能指针"><a href="#17-以独立语句将newed对象置入智能指针" class="headerlink" title="17.以独立语句将newed对象置入智能指针"></a><strong>17.以独立语句将newed对象置入智能指针</strong></h3><p>待续—————————</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-视c-为一个语言联邦&quot;&gt;&lt;a href=&quot;#1-视c-为一个语言联邦&quot; class=&quot;headerlink&quot; title=&quot;1.视c++为一个语言联邦&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.视c++为一个语言联邦&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;C&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://guiyinlun.com/categories/C/"/>
    
    
    <category term="#C++" scheme="https://guiyinlun.com/tags/C/"/>
    
    <category term="#Effective C++" scheme="https://guiyinlun.com/tags/Effective-C/"/>
    
    <category term="#学习笔记" scheme="https://guiyinlun.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="https://guiyinlun.com/post/4896de77.html"/>
    <id>https://guiyinlun.com/post/4896de77.html</id>
    <published>2023-05-05T09:03:15.000Z</published>
    <updated>2024-06-06T01:52:18.879Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.资源</strong></p><p><a href="https://gitee.com/all-about-git">https://gitee.com/all-about-git</a></p><p><strong>2.配置用户名和邮箱</strong></p><p>$ git config —global user.name “gan” $ git config —global user.email 1178814817@qq.com</p><p><strong>3.关系</strong></p><p><img src="https://cdn.jsdelivr.net/gh/guiyinlun/myimg/img/202309111015283.png" alt=""></p><p><strong>4.使用ssh</strong></p><p>这里必须设置</p><p><img src="https://cdn.jsdelivr.net/gh/guiyinlun/myimg/mdimg/202309111013713.png" alt=""></p><p><strong>5.更换远端</strong></p><p>git remote remove origin   //移除原来远程git仓库地址</p><p>git remote add origin 新仓库地址xxx    //添加新git仓库地址</p><p><strong>6.发布</strong></p><p>git add .</p><p>git commit -m “xxxx”</p><p>git tag v1.22.831.1</p><p>git push origin main</p><p>git push —tags</p><p><strong>问题</strong></p><p>fatal: refusing to merge unrelated histories</p><p>git pull origin master —allow-unrelated-histories</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;1.资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/all-about-git&quot;&gt;https://gitee.com/all-about-git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.配置用户名和邮箱&lt;/str</summary>
      
    
    
    
    <category term="Git" scheme="https://guiyinlun.com/categories/Git/"/>
    
    
    <category term="#教程" scheme="https://guiyinlun.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="#Git" scheme="https://guiyinlun.com/tags/Git/"/>
    
    <category term="#问题解决" scheme="https://guiyinlun.com/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
  </entry>
  
</feed>
